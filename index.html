<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle</title>
    <!-- Load Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 2rem;
            padding-bottom: 2rem;
        }

        /* Styles for individual character tiles */
        .tile {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.75rem; /* 28px */
            font-weight: 700;
            color: #1f2937; /* Gray-800 */
            border: 2px solid #d1d5db; /* Gray-300 */
            transition: all 0.2s ease-in-out;
            user-select: none;
            cursor: default;
        }

        .tile-filled {
            border-color: #9ca3af; /* Gray-400 */
            animation: pop 0.1s ease-out;
        }

        /* Color for correct position */
        .tile-correct {
            background-color: #10b981; /* Green-500 */
            border-color: #10b981;
            color: white;
        }
        /* Color for correct letter, wrong position */
        .tile-present {
            background-color: #f59e0b; /* Amber-500 */
            border-color: #f59e0b;
            color: white;
        }
        /* Color for letter not in the word */
        .tile-absent {
            background-color: #6b7280; /* Gray-500 */
            border-color: #6b7280;
            color: white;
        }

        /* Animation when tile is filled */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Keyboard button styles: REMOVED min-width: 43px; to fix mobile overflow */
        .key {
            height: 58px;
            flex: 1; /* Allows keys to shrink proportionally */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 8px;
            font-size: 0.875rem;
            font-weight: 700;
            color: #1f2937;
            background-color: #d1d5db; /* Gray-300 */
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }

        .key:active {
            filter: brightness(0.9);
        }

        .key-lg {
            flex-grow: 1.5;
        }

        /* Keyboard colors after a guess */
        .key-correct { background-color: #10b981 !important; color: white; }
        .key-present { background-color: #f59e0b !important; color: white; }
        .key-absent { background-color: #6b7280 !important; color: white; }

        /* Grid sizing for mobile responsiveness */
        #game-grid {
            width: 100%;
            max-width: 350px; /* Maximum width for the grid */
        }
        
        /* Loading Spinner style */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #10b981; /* Green-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile keyboard adjustment: Ensures keyboard fits within the screen padding */
        #keyboard {
            max-width: 500px; 
            padding: 0 4px; /* Slight padding to prevent keys from touching screen edges */
        }

    </style>
</head>
<body onkeypress="handleKeyPress(event)">
    <div id="app" class="w-full max-w-lg mx-auto p-4 flex flex-col items-center justify-between min-h-[90vh]">
        
        <!-- Header Section -->
        <header class="w-full mb-6 relative">
            <!-- Restart Button (Top-left) -->
            <button id="restart-button" onclick="resetGame()" 
                    class="absolute left-0 top-1/2 -translate-y-1/2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-3 rounded-lg text-sm shadow transition duration-150 transform hover:scale-105">
                Restart
            </button>
            <h1 class="text-4xl font-bold text-gray-800 tracking-wider border-b-2 border-gray-300 pb-2 text-center">WORDLE</h1>
        </header>
        
        <!-- Loading Indicator -->
        <div id="loading-indicator" class="flex flex-col items-center justify-center h-full w-full my-12">
            <div class="spinner mb-4"></div>
            <p class="text-gray-600 font-semibold">Loading Dictionary...</p>
        </div>


        <!-- Game Grid Section (Hidden initially) -->
        <div id="game-grid" class="grid grid-cols-5 gap-1.5 w-full aspect-[5/6] mb-8 hidden">
            <!-- 6 rows x 5 tiles will be created by JavaScript -->
        </div>

        <!-- Message/Status Box -->
        <div id="message-box" class="h-10 text-center text-lg font-bold text-gray-800 transition-opacity duration-300 mb-4"></div>

        <!-- On-Screen Keyboard Section (Hidden initially) -->
        <div id="keyboard" class="w-full max-w-md flex flex-col items-center space-y-1 hidden">
            <!-- Row 1: QWERTY... -->
            <div class="flex space-x-1 w-full justify-center">
                <div class="key" data-key="Q">Q</div>
                <div class="key" data-key="W">W</div>
                <div class="key" data-key="E">E</div>
                <div class="key" data-key="R">R</div>
                <div class="key" data-key="T">T</div>
                <div class="key" data-key="Y">Y</div>
                <div class="key" data-key="U">U</div>
                <div class="key" data-key="I">I</div>
                <div class="key" data-key="O">O</div>
                <div class="key" data-key="P">P</div>
            </div>
            <!-- Row 2: ASDF... (Adjusted for better centering on mobile) -->
            <div class="flex space-x-1 w-full justify-center">
                <div class="key" data-key="A">A</div>
                <div class="key" data-key="S">S</div>
                <div class="key" data-key="D">D</div>
                <div class="key" data-key="F">F</div>
                <div class="key" data-key="G">G</div>
                <div class="key" data-key="H">H</div>
                <div class="key" data-key="J">J</div>
                <div class="key" data-key="K">K</div>
                <div class="key" data-key="L">L</div>
            </div>
            <!-- Row 3: ENTER, ZXC... BACKSPACE -->
            <div class="flex space-x-1 w-full justify-center">
                <div class="key key-lg" data-key="ENTER">ENTER</div>
                <div class="key" data-key="Z">Z</div>
                <div class="key" data-key="X">X</div>
                <div class="key" data-key="C">C</div>
                <div class="key" data-key="V">V</div>
                <div class="key" data-key="B">B</div>
                <div class="key" data-key="N">N</div>
                <div class="key" data-key="M">M</div>
                <!-- BACKSPACE virtual key -->
                <div class="key key-lg" data-key="BACKSPACE">âŒ«</div>
            </div>
        </div>

        <!-- Result Modal -->
        <div id="result-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
            <div class="bg-white rounded-xl shadow-2xl p-6 text-center max-w-sm w-full transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
                <h2 id="modal-title" class="text-3xl font-extrabold mb-4 text-gray-800"></h2>
                <p class="text-xl text-gray-600 mb-6">The word was: <span id="modal-answer" class="font-bold text-green-600"></span></p>
                <!-- Button to close Modal without restarting the game -->
                <button onclick="closeModalOnly()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script>
        // Define variables for dictionary data
        let ANSWERS = []; // The correct words (from words-answer.json)
        let VALID_GUESSES = []; // All allowed guess words (from words.json)

        // Fallback data if JSON loading fails
        const FALLBACK_ANSWERS = [
            "APPLE", "TRAIN", "HOUSE", "GRAPE", "CRANE",
            "BLAST", "PIANO", "SWEET", "FIGHT", "OCEAN"
        ];
        const FALLBACK_GUESSES = [
            "ABOVE", "ABOUT", "ACUTE", "ADMIT", "ALIVE", "BLAST",
            "CRANE", "DRIVE", "EAGER", "EATEN", "ERROR", "FIBER",
            "FLASH", "FOUND", "GRADE", "HEART", "HELLO", "IMAGE",
            "JOINT", "KNIFE", "LIGHT", "MANGO", "OCEAN", "OFTEN",
            "PLANT", "POWER", "QUICK", "SIGHT", "SMART", "SWEET",
            "TABLE", "TIGER", "TRAIN", "VOICE", "WATER", "WHALE",
            "WIDOW", "WORLD", "YIELD",
        ];


        const WORD_LENGTH = 5;
        const MAX_GUESSES = 6;

        let targetWord = "";
        let currentGuess = "";
        let currentRow = 0;
        let isGameOver = false;

        const gridEl = document.getElementById('game-grid');
        const messageBoxEl = document.getElementById('message-box');
        const keyboardEl = document.getElementById('keyboard');
        const modalEl = document.getElementById('result-modal');
        const modalContentEl = document.getElementById('modal-content');
        const loadingEl = document.getElementById('loading-indicator');

        // --- Game Setup Functions ---

        /** Load words from JSON files (words.json and words-answer.json) */
        async function fetchWords() {
            // Check for file:// protocol to avoid CORS issues
            if (window.location.protocol === 'file:') {
                console.warn("Running on file:// protocol: Cannot load external JSON files due to security restrictions (CORS). Using fallback dictionary.");
                ANSWERS = FALLBACK_ANSWERS;
                // Ensure all answers are in the valid guess list
                VALID_GUESSES = [...FALLBACK_GUESSES, ...FALLBACK_ANSWERS];
                // Show temporary warning to the user
                showMessage("Running locally: Using fallback dictionary due to security restrictions", 5000);
            } else {
                try {
                    // 1. Fetch answers
                    const answersResponse = await fetch('words-answer.json');
                    const answersData = await answersResponse.json();
                    ANSWERS = answersData;
                    
                    // 2. Fetch all allowed guesses
                    const guessesResponse = await fetch('words.json');
                    const guessesData = await guessesResponse.json();
                    VALID_GUESSES = guessesData;
                    
                } catch (error) {
                    console.error("Error loading JSON dictionary files:", error);
                    
                    // Fallback: Use built-in dictionary
                    ANSWERS = FALLBACK_ANSWERS;
                    VALID_GUESSES = FALLBACK_GUESSES;

                    // Show notification to the user
                    showMessage("Could not load dictionary! Using fallback English words (check JSON files)", 5000);
                }
            }
            

            // Process loaded (or fallback) words
            if (ANSWERS.length === 0) {
                 // Fallback if the first attempt failed
                 ANSWERS = FALLBACK_ANSWERS; 
                 VALID_GUESSES = [...FALLBACK_GUESSES, ...FALLBACK_ANSWERS];
            }

            // Convert all words to uppercase
            ANSWERS = ANSWERS.map(word => String(word).toUpperCase());
            VALID_GUESSES = VALID_GUESSES.map(word => String(word).toUpperCase());

            // Ensure all answers are in the valid guess list
            for (const answer of ANSWERS) {
                if (!VALID_GUESSES.includes(answer)) {
                    VALID_GUESSES.push(answer);
                }
            }
        }

        /** Randomly selects the target word and initializes game state */
        function initializeGame() {
            // Hide Loading and show Grid/Keyboard
            loadingEl.classList.add('hidden');
            gridEl.classList.remove('hidden');
            keyboardEl.classList.remove('hidden');

            if (ANSWERS.length === 0) {
                showMessage("Error: No words loaded! Please check the JSON files.", 10000);
                isGameOver = true;
                return;
            }

            // Select a random answer
            const randomIndex = Math.floor(Math.random() * ANSWERS.length);
            targetWord = ANSWERS[randomIndex];

            // Reset game state
            currentGuess = "";
            currentRow = 0;
            isGameOver = false;

            // Clear display
            gridEl.innerHTML = '';
            messageBoxEl.textContent = '';
            
            createGrid();
            resetKeyboardColors();

            console.log("Target Word: " + targetWord); // For debugging
        }

        /** Creates the 6x5 grid of tiles */
        function createGrid() {
            for (let i = 0; i < MAX_GUESSES; i++) {
                for (let j = 0; j < WORD_LENGTH; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile rounded-lg';
                    // Assign ID to each tile for easy update
                    tile.id = `tile-${i}-${j}`;
                    gridEl.appendChild(tile);
                }
            }
        }

        // --- Game Logic Functions ---

        /** Displays the current guess on the grid */
        function updateDisplay() {
            // Clear the current row first
            for (let i = 0; i < WORD_LENGTH; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                tileEl.textContent = '';
                tileEl.classList.remove('tile-filled');
            }

            // Write characters
            for (let i = 0; i < currentGuess.length; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                tileEl.textContent = currentGuess[i];
                tileEl.classList.add('tile-filled');
            }
        }

        /** Displays a temporary status message */
        function showMessage(message, duration = 2000) {
            messageBoxEl.textContent = message;
            messageBoxEl.style.opacity = '1';
            setTimeout(() => {
                messageBoxEl.style.opacity = '0';
            }, duration);
        }

        /** Checks the guess and provides color feedback when ENTER is pressed */
        function checkGuess() {
            if (currentGuess.length !== WORD_LENGTH) {
                showMessage("Word is not 5 letters long!");
                return;
            }

            if (!VALID_GUESSES.includes(currentGuess)) {
                showMessage("Word is not in the allowed list!");
                return;
            }

            const target = targetWord;
            const guess = currentGuess;
            const results = Array(WORD_LENGTH).fill('absent'); // 'correct', 'present', 'absent'
            
            // Use a Map to track remaining characters in the target word
            const targetMap = new Map();
            for (const char of target) {
                targetMap.set(char, (targetMap.get(char) || 0) + 1);
            }

            // 1. First pass: Find 'correct' positions
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (guess[i] === target[i]) {
                    results[i] = 'correct';
                    targetMap.set(guess[i], targetMap.get(guess[i]) - 1);
                }
            }

            // 2. Second pass: Find 'present' and 'absent'
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (results[i] === 'correct') continue;

                const char = guess[i];
                if (targetMap.has(char) && targetMap.get(char) > 0) {
                    results[i] = 'present';
                    targetMap.set(char, targetMap.get(char) - 1);
                } else {
                    results[i] = 'absent';
                }
            }

            // 3. Apply results to Grid and Keyboard
            for (let i = 0; i < WORD_LENGTH; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                
                // Remove previous styles
                tileEl.classList.remove('tile-filled');
                
                // Add new color style
                tileEl.classList.add(`tile-${results[i]}`);

                // Update keyboard color
                updateKeyboardColor(guess[i], results[i]);
            }

            // 4. Check end game conditions
            if (guess === target) {
                endGame(true); // Win
            } else if (currentRow === MAX_GUESSES - 1) {
                endGame(false); // Lose
            } else {
                currentRow++;
                currentGuess = "";
            }
        }

        // --- Keyboard Handling Functions ---

        /** Handles key press from both physical and virtual keyboards */
        function handleKey(key) {
            if (isGameOver) return;

            const normalizedKey = key.toUpperCase();

            if (normalizedKey === 'ENTER') {
                checkGuess();
            } 
            // Logic for backspace/delete
            else if (normalizedKey === 'BACKSPACE' || normalizedKey === 'DEL') {
                // Remove the last character from currentGuess
                currentGuess = currentGuess.slice(0, -1);
                // Update the display to reflect the deletion
                updateDisplay();
            } 
            // Logic for character input
            else if (normalizedKey.length === 1 && /^[A-Z]$/.test(normalizedKey) && currentGuess.length < WORD_LENGTH) {
                currentGuess += normalizedKey;
                updateDisplay();
            }
        }

        /** Captures physical keyboard presses (Desktop) */
        function handleKeyPress(event) {
            const key = event.key;

            if (key === 'Enter') {
                handleKey('ENTER');
            } 
            // Capture and handle Backspace key from physical keyboard
            else if (key === 'Backspace') {
                // Prevent default browser behavior (like navigating back)
                event.preventDefault(); 
                handleKey('BACKSPACE');
            } 
            // Capture letter keys
            else if (key.length === 1 && /^[a-zA-Z]$/.test(key)) {
                handleKey(key.toUpperCase());
            }
        }

        /** Sets up Event Listeners for the virtual on-screen keyboard */
        function setupKeyboardListeners() {
            keyboardEl.addEventListener('click', (event) => {
                const keyEl = event.target.closest('.key');
                if (keyEl) {
                    const key = keyEl.dataset.key;
                    handleKey(key);
                }
            });
        }

        /** Updates the color of a key on the virtual keyboard */
        function updateKeyboardColor(char, result) {
            const keyEl = keyboardEl.querySelector(`[data-key="${char}"]`);
            if (!keyEl) return;

            const classes = ['key-correct', 'key-present', 'key-absent'];

            // Remove existing colors
            classes.forEach(cls => keyEl.classList.remove(cls));

            // Apply color based on precedence (Correct > Present > Absent)
            if (result === 'correct') {
                keyEl.classList.add('key-correct');
            } else if (result === 'present' && !keyEl.classList.contains('key-correct')) {
                keyEl.classList.add('key-present');
            } else if (result === 'absent' && !keyEl.classList.contains('key-correct') && !keyEl.classList.contains('key-present')) {
                keyEl.classList.add('key-absent');
            }
        }

        /** Resets all virtual keyboard key colors to default */
        function resetKeyboardColors() {
            const keys = keyboardEl.querySelectorAll('.key');
            const classes = ['key-correct', 'key-present', 'key-absent'];
            keys.forEach(key => {
                classes.forEach(cls => key.classList.remove(cls));
                key.style.backgroundColor = ''; // Revert to default Tailwind color
                key.style.color = '#1f2937';
            });
        }

        // --- End Game Functions ---

        /** Handles game conclusion (win/loss) */
        function endGame(isWin) {
            isGameOver = true;
            
            const titleEl = document.getElementById('modal-title');
            const answerEl = document.getElementById('modal-answer');

            answerEl.textContent = targetWord;
            
            if (isWin) {
                titleEl.textContent = "ðŸ¥³ Excellent! You guessed correctly! ðŸ¥³";
                titleEl.classList.remove('text-red-600');
                titleEl.classList.add('text-green-600');
            } else {
                titleEl.textContent = "ðŸ˜” Try again next time! ðŸ˜”";
                titleEl.classList.remove('text-green-600');
                titleEl.classList.add('text-red-600');
            }

            showModal();
        }

        /** Displays the result modal */
        function showModal() {
            modalEl.classList.remove('hidden', 'opacity-0');
            modalEl.classList.add('flex');
            // Animate the modal appearance
            setTimeout(() => {
                modalEl.classList.remove('opacity-0');
                modalContentEl.classList.remove('scale-95', 'opacity-0');
                modalContentEl.classList.add('scale-100', 'opacity-100');
            }, 10);
        }

        /** Closes the modal without restarting the game */
        function closeModalOnly() {
            modalEl.classList.remove('flex');
            modalEl.classList.add('hidden', 'opacity-0');
            modalContentEl.classList.remove('scale-100', 'opacity-100');
            modalContentEl.classList.add('scale-95', 'opacity-0');
        }

        /** Closes the modal and starts a new game */
        function resetGame() {
            closeModalOnly(); // Close modal first
            // Restart the entire initialization process
            init(); 
        }

        /** Main function to start the application */
        async function init() {
            loadingEl.classList.remove('hidden');
            gridEl.classList.add('hidden');
            keyboardEl.classList.add('hidden');
            
            await fetchWords(); // Wait for dictionary loading
            
            initializeGame();
            setupKeyboardListeners();
        }

        // --- Start Application ---
        window.onload = function() {
            init();
        };

    </script>
</body>
</html>
