<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Clone</title>
    <!-- Load Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 2rem;
            padding-bottom: 2rem;
        }

        /* Styles for individual character tiles */
        .tile {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.75rem; 
            font-weight: 700;
            color: #1f2937; 
            border: 2px solid #d1d5db; 
            transition: all 0.2s ease-in-out;
            user-select: none;
            cursor: default;
        }

        .tile-filled {
            border-color: #9ca3af; 
            animation: pop 0.1s ease-out;
        }

        /* Colors */
        .tile-correct { background-color: #10b981; border-color: #10b981; color: white; }
        .tile-present { background-color: #f59e0b; border-color: #f59e0b; color: white; }
        .tile-absent { background-color: #6b7280; border-color: #6b7280; color: white; }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Keyboard button styles */
        .key {
            height: 58px;
            flex: 1; 
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 8px;
            font-size: 0.875rem;
            font-weight: 700;
            color: #1f2937;
            background-color: #d1d5db; /* Gray-300 */
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }

        .key:active {
            filter: brightness(0.9);
        }

        .key-lg {
            flex-grow: 1.5;
        }

        /* Keyboard colors - MUST use !important for precedence */
        .key-correct { background-color: #10b981 !important; color: white; }
        .key-present { background-color: #f59e0b !important; color: white; }
        .key-absent { background-color: #6b7280 !important; color: white; }

        /* Mobile responsiveness and centering */
        #game-grid {
            width: 100%;
            max-width: 350px; 
            /* Custom aspect-ratio to make the 5x6 grid slightly shorter (original H/W was 1.2) */
            aspect-ratio: 5 / 5.8; 
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #10b981; 
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #keyboard {
            max-width: 500px; 
            padding: 0 4px; 
        }

    </style>
</head>
<body>
    <div id="app" class="w-full max-w-lg mx-auto p-4 flex flex-col items-center justify-between min-h-[90vh]">
        
        <!-- Header Section -->
        <header class="w-full mb-6 relative">
            <!-- Restart Button (Updated text) -->
            <button id="restart-button" onclick="resetGame()" 
                    class="absolute left-0 top-1/2 -translate-y-1/2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-3 rounded-lg text-sm shadow transition duration-150 transform hover:scale-105">
                Give Up & Restart
            </button>
            <h1 class="text-4xl font-bold text-gray-800 tracking-wider border-b-2 border-gray-300 pb-2 text-center">WORDLE</h1>
        </header>
        
        <!-- Loading Indicator -->
        <div id="loading-indicator" class="flex flex-col items-center justify-center h-full w-full my-12">
            <div class="spinner mb-4"></div>
            <!-- Updated loading message -->
            <p id="loading-message" class="text-gray-600 font-semibold text-center">Summoning Words... Hang Tight.</p>
        </div>

        <!-- Game Grid Section (Removed aspect class, now defined in CSS) -->
        <div id="game-grid" class="grid grid-cols-5 gap-1.5 w-full mb-8 hidden">
            <!-- Grid will be dynamically created by JavaScript -->
        </div>

        <!-- Message/Status Box -->
        <div id="message-box" class="h-10 text-center text-lg font-bold text-gray-800 transition-opacity duration-300 mb-4"></div>

        <!-- On-Screen Keyboard Section -->
        <div id="keyboard" class="w-full max-w-md flex flex-col items-center space-y-1 hidden">
            <!-- Keyboard Rows (Standard QWERTY layout) -->
            <div class="flex space-x-1 w-full justify-center">
                <div class="key" data-key="Q">Q</div>
                <div class="key" data-key="W">W</div>
                <div class="key" data-key="E">E</div>
                <div class="key" data-key="R">R</div>
                <div class="key" data-key="T">T</div>
                <div class="key" data-key="Y">Y</div>
                <div class="key" data-key="U">U</div>
                <div class="key" data-key="I">I</div>
                <div class="key" data-key="O">O</div>
                <div class="key" data-key="P">P</div>
            </div>
            <div class="flex space-x-1 w-full justify-center">
                <div class="key" data-key="A">A</div>
                <div class="key" data-key="S">S</div>
                <div class="key" data-key="D">D</div>
                <div class="key" data-key="F">F</div>
                <div class="key" data-key="G">G</div>
                <div class="key" data-key="H">H</div>
                <div class="key" data-key="J">J</div>
                <div class="key" data-key="K">K</div>
                <div class="key" data-key="L">L</div>
            </div>
            <div class="flex space-x-1 w-full justify-center">
                <div class="key key-lg" data-key="ENTER">ENTER</div>
                <div class="key" data-key="Z">Z</div>
                <div class="key" data-key="X">X</div>
                <div class="key" data-key="C">C</div>
                <div class="key" data-key="V">V</div>
                <div class="key" data-key="B">B</div>
                <div class="key" data-key="N">N</div>
                <div class="key" data-key="M">M</div>
                <div class="key key-lg" data-key="BACKSPACE">⌫</div>
            </div>
        </div>

        <!-- Result Modal -->
        <div id="result-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
            <div class="bg-white rounded-xl shadow-2xl p-6 text-center max-w-sm w-full transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
                <h2 id="modal-title" class="text-3xl font-extrabold mb-4 text-gray-800"></h2>
                <!-- Updated answer text -->
                <p class="text-xl text-gray-600 mb-6">ANSWER: <span id="modal-answer" class="font-bold text-green-600"></span></p>
                <!-- Updated button text -->
                <button onclick="closeModalOnly()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                    Fine, I'll Close
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- GLOBAL STATE ---
        let ANSWERS = []; // Target words
        let VALID_GUESSES = []; // All allowed guess words
        
        const WORD_LENGTH = 5;
        const MAX_GUESSES = 6;

        let targetWord = "";
        let currentGuess = "";
        let currentRow = 0;
        let isGameOver = false;

        // --- DOM Elements ---
        const gridEl = document.getElementById('game-grid');
        const messageBoxEl = document.getElementById('message-box');
        const keyboardEl = document.getElementById('keyboard');
        const modalEl = document.getElementById('result-modal');
        const modalContentEl = document.getElementById('modal-content');
        const loadingEl = document.getElementById('loading-indicator');
        const loadingMessageEl = document.getElementById('loading-message');
        
        /** Utility function to pause execution */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- CORE ASYNCHRONOUS LOGIC: FETCH & RETRY ---

        /** * Fetches words from JSON files. This function includes an infinite retry loop 
         * until both files are successfully loaded and contain data. NO FALLBACK IS USED.
         */
        async function fetchWordsAndRetry() {
            loadingMessageEl.textContent = "Summoning Words... Hang Tight.";
            loadingEl.classList.remove('hidden');

            while (true) {
                try {
                    // 1. Fetch answers (words-answer.json)
                    const answersResponse = await fetch('words-answer.json');
                    if (!answersResponse.ok) throw new Error('Failed to fetch answers file.');
                    const answersData = await answersResponse.json();
                    
                    // 2. Fetch all allowed guesses (words.json)
                    const guessesResponse = await fetch('words.json');
                    if (!guessesResponse.ok) throw new Error('Failed to fetch words file.');
                    const guessesData = await guessesResponse.json();
                    
                    // 3. Validation
                    const answers = answersData.map(word => String(word).toUpperCase());
                    let guesses = guessesData.map(word => String(word).toUpperCase());
                    
                    if (answers.length === 0 || guesses.length === 0) {
                        throw new Error('Dictionary files were loaded but contain no words.');
                    }
                    
                    // Ensure all answers are valid guesses
                    for (const answer of answers) {
                        if (!guesses.includes(answer)) {
                            guesses.push(answer);
                        }
                    }

                    // Store results globally and break the loop
                    ANSWERS = answers;
                    VALID_GUESSES = guesses;
                    break; 

                } catch (error) {
                    // Log error and retry
                    console.error("Error loading JSON dictionary files. Retrying in 3 seconds...", error);
                    // Updated error message with witty tone
                    loadingMessageEl.textContent = `Word files missing! (Doh! ${error.message}). Retrying in 3 secs...`; 
                    await sleep(3000); // Wait 3 seconds before retrying
                }
            }
        }

        // --- GAME INITIALIZATION & SETUP ---

        /** Randomly selects the target word and initializes game state */
        function initializeGame() {
            // Check if loading was successful
            if (ANSWERS.length === 0) {
                // Updated severe error message
                showMessage("Fatal Error: No Words! Seriously? Refresh the page, pal.", 0);
                isGameOver = true;
                loadingEl.classList.remove('hidden');
                gridEl.classList.add('hidden');
                keyboardEl.classList.add('hidden');
                return;
            }

            // Hide Loading and show Grid/Keyboard
            loadingEl.classList.add('hidden');
            gridEl.classList.remove('hidden');
            keyboardEl.classList.remove('hidden');

            // Select a random answer
            const randomIndex = Math.floor(Math.random() * ANSWERS.length);
            targetWord = ANSWERS[randomIndex];

            // Reset game state
            currentGuess = "";
            currentRow = 0;
            isGameOver = false;

            // Clear display and keyboard
            gridEl.innerHTML = '';
            messageBoxEl.textContent = '';
            
            createGrid();
            resetKeyboardColors();

            // Updated debug message
            console.log("Shhh... The Target Word (Debug) is: " + targetWord);
        }

        /** Creates the 6x5 grid of tiles */
        function createGrid() {
            for (let i = 0; i < MAX_GUESSES; i++) {
                for (let j = 0; j < WORD_LENGTH; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile rounded-lg';
                    tile.id = `tile-${i}-${j}`;
                    gridEl.appendChild(tile);
                }
            }
        }

        // --- GAMEPLAY LOGIC ---

        /** Displays the current guess on the grid */
        function updateDisplay() {
            // 1. Clear the current row
            for (let i = 0; i < WORD_LENGTH; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                if (i >= currentGuess.length) {
                    tileEl.textContent = '';
                    tileEl.classList.remove('tile-filled');
                }
            }

            // 2. Write characters
            for (let i = 0; i < currentGuess.length; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                tileEl.textContent = currentGuess[i];
                tileEl.classList.add('tile-filled');
            }
        }

        /** Displays a temporary status message */
        function showMessage(message, duration = 2000) {
            messageBoxEl.textContent = message;
            messageBoxEl.style.opacity = '1';
            if (duration > 0) {
                setTimeout(() => {
                    messageBoxEl.style.opacity = '0';
                }, duration);
            }
        }

        /** Checks the guess and provides color feedback */
        function checkGuess() {
            if (currentGuess.length !== WORD_LENGTH) {
                // Updated message
                showMessage("Five letters only, genius.");
                return;
            }

            if (!VALID_GUESSES.includes(currentGuess)) {
                // Updated message
                showMessage("That's not a word, try again.");
                return;
            }

            const target = targetWord;
            const guess = currentGuess;
            const results = Array(WORD_LENGTH).fill('absent'); 
            
            // Map to track remaining letters in target word for accurate 'present' check
            const targetMap = new Map();
            for (const char of target) {
                targetMap.set(char, (targetMap.get(char) || 0) + 1);
            }

            // 1. First pass: Find 'correct' positions (Green)
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (guess[i] === target[i]) {
                    results[i] = 'correct';
                    targetMap.set(guess[i], targetMap.get(guess[i]) - 1);
                }
            }

            // 2. Second pass: Find 'present' (Orange)
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (results[i] === 'correct') continue;

                const char = guess[i];
                if (targetMap.has(char) && targetMap.get(char) > 0) {
                    results[i] = 'present';
                    targetMap.set(char, targetMap.get(char) - 1);
                }
                // If it's not correct and not present (map count is 0), it remains 'absent'
            }

            // 3. Apply results to Grid and Keyboard
            for (let i = 0; i < WORD_LENGTH; i++) {
                const tileEl = document.getElementById(`tile-${currentRow}-${i}`);
                
                // Add color style
                tileEl.classList.add(`tile-${results[i]}`);
                // Ensure pop animation and remove temporary filled style
                tileEl.classList.remove('tile-filled');

                // Update keyboard color with correct precedence
                updateKeyboardColor(guess[i], results[i]);
            }

            // 4. Check end game conditions
            if (guess === target) {
                endGame(true); // Win
            } else if (currentRow === MAX_GUESSES - 1) {
                endGame(false); // Lose
            } else {
                // Advance to next row
                currentRow++;
                currentGuess = "";
            }
        }

        // --- KEYBOARD & INPUT MANAGEMENT ---

        /** Handles key press from both physical and virtual keyboards */
        function handleKey(key) {
            if (isGameOver) return;

            const normalizedKey = key.toUpperCase();

            if (normalizedKey === 'ENTER') {
                checkGuess();
            } 
            else if (normalizedKey === 'BACKSPACE' || normalizedKey === 'DEL') {
                currentGuess = currentGuess.slice(0, -1);
                updateDisplay();
            } 
            // Only accept single capital letters and ensure word length limit
            else if (normalizedKey.length === 1 && /^[A-Z]$/.test(normalizedKey) && currentGuess.length < WORD_LENGTH) {
                currentGuess += normalizedKey;
                updateDisplay();
            }
        }

        /** Handles physical keyboard presses (Attached only once on window load) */
        function handlePhysicalKey(event) {
            if (isGameOver) return;
            
            const key = event.key;

            if (key === 'Enter') {
                event.preventDefault(); 
                handleKey('ENTER');
            } 
            else if (key === 'Backspace') {
                event.preventDefault(); 
                handleKey('BACKSPACE');
            } 
            else if (key.length === 1 && /^[a-zA-Z]$/.test(key)) {
                handleKey(key.toUpperCase());
            }
        }


        /** Updates the color of a key on the virtual keyboard, prioritizing Correct > Present > Absent. */
        function updateKeyboardColor(char, result) {
            const keyEl = keyboardEl.querySelector(`[data-key="${char}"]`);
            if (!keyEl) return;

            // Get current color state (check for existing higher priority colors)
            const isCorrect = keyEl.classList.contains('key-correct');
            const isPresent = keyEl.classList.contains('key-present');
            
            // Priority Check: Correct > Present > Absent
            if (result === 'correct') {
                // Green always wins
                keyEl.classList.remove('key-present', 'key-absent');
                keyEl.classList.add('key-correct');
            } else if (result === 'present' && !isCorrect) {
                // Orange wins over gray, but not over green
                keyEl.classList.remove('key-absent');
                keyEl.classList.add('key-present');
            } else if (result === 'absent' && !isCorrect && !isPresent) {
                // Gray only applies if neither green nor orange is present
                keyEl.classList.add('key-absent');
            }
        }

        /** Resets all virtual keyboard key colors to default */
        function resetKeyboardColors() {
            const keys = keyboardEl.querySelectorAll('.key');
            const classes = ['key-correct', 'key-present', 'key-absent'];
            keys.forEach(key => {
                classes.forEach(cls => key.classList.remove(cls));
                // Reset custom styles if they were applied
                key.style.backgroundColor = ''; 
                key.style.color = '#1f2937';
            });
        }

        // --- MODAL & GAME END ---

        function endGame(isWin) {
            isGameOver = true;
            
            const titleEl = document.getElementById('modal-title');
            const answerEl = document.getElementById('modal-answer');

            answerEl.textContent = targetWord;
            
            if (isWin) {
                // Updated win message
                titleEl.textContent = "🐖 Nailed It! You're FAT! 🐖";
                titleEl.classList.remove('text-red-600');
                titleEl.classList.add('text-green-600');
            } else {
                // Updated lose message
                titleEl.textContent = "🐷 Oops, not surprise that you are fat...  🐷";
                titleEl.classList.remove('text-green-600');
                titleEl.classList.add('text-red-600');
            }

            showModal();
        }

        function showModal() {
            modalEl.classList.remove('hidden');
            modalEl.classList.add('flex');
            setTimeout(() => {
                modalContentEl.classList.remove('scale-95', 'opacity-0');
                modalContentEl.classList.add('scale-100', 'opacity-100');
            }, 10);
        }

        function closeModalOnly() {
            modalEl.classList.remove('flex');
            modalEl.classList.add('hidden');
            modalContentEl.classList.remove('scale-100', 'opacity-100');
            modalContentEl.classList.add('scale-95', 'opacity-0');
        }

        /** Handles restarting the game (by re-initializing) */
        function resetGame() {
            closeModalOnly(); 
            // No need to refetch words, just re-initialize the game state
            initializeGame(); 
        }

        /** Main entry point for the application, handles initial setup including word loading */
        async function init() {
            // 1. Fetch words (with infinite retry)
            await fetchWordsAndRetry(); 
            
            // 2. Start game once words are loaded
            initializeGame();
        }

        // --- APPLICATION STARTUP ---

        /** Attach ALL Event Listeners ONCE when the window loads. */
        window.onload = function() {
            // 1. Virtual Keyboard Listener (Attached only once)
            keyboardEl.addEventListener('click', (event) => {
                const keyEl = event.target.closest('.key');
                if (keyEl) {
                    const key = keyEl.dataset.key;
                    handleKey(key);
                }
            });

            // 2. Physical Keyboard Listener (Attached only once, fixing the 'AA' bug)
            document.addEventListener('keydown', handlePhysicalKey);
            
            // 3. Start the game flow
            init();
        };

    </script>
</body>
</html>

